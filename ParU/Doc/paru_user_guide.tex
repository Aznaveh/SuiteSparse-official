\documentclass[12pt]{article}
\batchmode
\usepackage{hyperref}
\usepackage{minted}

\topmargin -0.5in
\textheight 9.0in
\oddsidemargin 0pt
\evensidemargin 0pt
\textwidth 6.5in

%-------------------------------------------------------------------------------
% get epsf.tex file, for encapsulated postscript files:
\input epsf
%-------------------------------------------------------------------------------
% macro for Postscript figures the easy way
% usage:  \postscript{file.ps}{scale}
% where scale is 1.0 for 100%, 0.5 for 50% reduction, etc.
%
\newcommand{\postscript}[2]
{\setlength{\epsfxsize}{#2\hsize}
\centerline{\epsfbox{#1}}}
%-------------------------------------------------------------------------------

\title{User's Guide for ParU, an unsymmetric multifrontal multithreaded sparse
LU factorization package}
\author{Mohsen Aznaveh\thanks{email: aznaveh@tamu.edu.},
Timothy A. Davis\thanks{email: DrTimothyAldenDavis@gmail.com,
http://www.suitesparse.com.}}

\input{paru_version.tex}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------
\maketitle

\begin{abstract}

ParU is an implementation of the multifrontal sparse LU factorization
method.  Parallelism is exploited both in the BLAS and across different frontal
matrices using OpenMP tasking, a shared-memory programming model for modern
multicore architectures. The package is written in C++ and real sparse matrices
are supported.

ParU, Copyright (c) 2022-2024, Mohsen Aznaveh and Timothy A. Davis,
All Rights Reserved.
SPDX-License-Identifier: GPL-3.0-or-later
\end{abstract}

\newpage
{\small
\tableofcontents
}

%-------------------------------------------------------------------------------
\section{Introduction}
\label{intro}
%-------------------------------------------------------------------------------

The algorithms used in ParU are discussed in a companion paper.
% FIXME NOW: cite our ACM TOMS submission, and include it the Doc folder
This document gives detailed information on the installation and use of ParU.
ParU is a parallel sparse direct solver that uses OpenMP tasking for
parallelism. ParU calls UMFPACK for the symbolic analysis phase, after that,
some symbolic analysis is done by ParU itself, and then the numeric phase
starts. The numeric computation is a task parallel phase using OpenMP, and each
task calls parallel BLAS; i.e. nested parallelism.  The performance of BLAS has
a heavy impact on the performance of ParU. Moreover, the way parallel BLAS can
be called in a nested environment can also be very important for ParU's
performance.

%-------------------------------------------------------------------------------
\section{Using ParU in C and C++}
%-------------------------------------------------------------------------------

ParU relies on CHOLMOD for its basic sparse matrix data structure, a compressed
sparse column format.  CHOLMOD provides interfaces to the AMD, COLAMD, and
METIS ordering methods and many other functions. ParU also relies on UMFPACK
for its symbolic analysis.

%-------------------------------------------------------------------------------
\subsection{Installing the C/C++ library on any system}
%-------------------------------------------------------------------------------

All of SuiteSparse can be built by \verb'cmake' with a single top-level
\verb'CMakeLists.txt' file.  In addition, each package (including ParU) has its
own \verb'CMakeLists.txt' file to build that package individually.  This is the
simplest method for building ParU and its dependent pacakges on all systems.

%-------------------------------------------------------------------------------
\subsection{Installing the C/C++ library on Linux/Unix}
%-------------------------------------------------------------------------------

In Linux/MacOs, type \verb'make' at the command line in either the
\verb'SuiteSparse' directory (which compiles all of SuiteSparse) or in the
\verb'SuiteSparse/ParU' directory (which just compiles ParU).  ParU will be
compiled; you can type \verb'make demos' to run a set of simple demos.

The use of \verb'make' is optional.  The top-level \verb'ParU/Makefile' is
a simple wrapper that uses \verb'cmake' to do the actual build.

To fully test the coverage of the lines ParU, go to the \verb'Tcov'
directory and type \verb'make'.  This test requires Linux.

To install the shared library (by default, into \verb'/usr/local/lib' and
\verb'/usr/local/include'), do {\tt make install}.  To uninstall, do
{\tt make uninstall}.  For more options, see the {\tt ParU/README.md} file.

%-------------------------------------------------------------------------------
\subsection{C/C++ Example}
%-------------------------------------------------------------------------------

Below is a simple C++ program that illustrates the use of ParU.  The program
reads in a problem from \verb'stdin' in MatrixMarket format
\cite{BoisvertPozoRemingtonBarrettDongarra97}, solves it, and prints the norm
of \verb'A' and the residual.  Some error testing code is omited to simplify
the program, but a robust user application should check the return values from
ParU.  The full program can be found in \verb'ParU/Demo/paru_simple.cpp'.  Note
that ParU supports only real double-precision matrices.

Refer to the CHOLMOD User guide for the CHOLMOD methods used below.

\begin{minted}{cpp}
#include <iostream>
#include <iomanip>
#include <ios>
#include "ParU.h"

int main(int argc, char **argv)
{
    cholmod_common Common, *cc;
    cholmod_sparse *A;
    ParU_Symbolic *Sym;
    //~~~~~~~~~Reading the input matrix and test if the format is OK~~~~~~~~~~~~
    // start CHOLMOD
    cc = &Common;
    int mtype;
    cholmod_l_start(cc);
    A = (cholmod_sparse *)cholmod_l_read_matrix(stdin, 1, &mtype, cc);
    //~~~~~~~~~~~~~~~~~~~Starting computation~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    std::cout << "================= ParU, a simple demo: ===================\n";
    ParU_Control Control;
    ParU_Analyze(A, &Sym, &Control);
    std::cout << "Input matrix is " << Sym->m << "x" << Sym->n
        << " nnz = " << Sym->anz << std::endl;
    ParU_Numeric *Num;
    ParU_Factorize(A, Sym, &Num, &Control);

    //~~~~~~~~~~~~~~~~~~~ Computing the residual, norm(b-Ax) ~~~~~~~~~~~~~~~~~~~
    int64_t m = Sym->m;
    double *b = (double *)malloc(m * sizeof(double));
    double *xx = (double *)malloc(m * sizeof(double));
    for (int64_t i = 0; i < m; ++i) b[i] = i + 1;
    ParU_Solve(Sym, Num, b, xx, &Control);
    double resid, anorm, xnorm;
    ParU_Residual(A, xx, b, resid, anorm, xnorm, &Control);
    double rresid = (anorm == 0 || xnorm == 0 ) ? 0 : (resid/(anorm*xnorm));
    std::cout << std::scientific << std::setprecision(2)
        << "Relative residual is |" << rresid << "| anorm is " << anorm
        << ", xnorm is " << xnorm << " and rcond is " << Num->rcond << "."
        << std::endl;
    free(b);
    free(xx);

    //~~~~~~~~~~~~~~~~~~~End computation~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ParU_FreeNumeric(&Num, &Control);
    ParU_FreeSymbolic(&Sym, &Control);
    cholmod_l_free_sparse(&A, cc);
    cholmod_l_finish(cc);
}
\end{minted}

A simple demo for the C interface is shown next. You can see the complete demo
in \verb'ParU/Demo/paru_simplec.c'.

\begin{minted}{c}
#include "ParU.h"
int main(int argc, char **argv)
{
    cholmod_common Common, *cc;
    cholmod_sparse *A;
    ParU_C_Symbolic *Sym;
    //~~~~~~~~~Reading the input matrix and test if the format is OK~~~~~~~~~~~~
    // start CHOLMOD
    cc = &Common;
    int mtype;
    cholmod_l_start(cc);
    // A = mread (stdin) ; read in the sparse matrix A
    A = (cholmod_sparse *)cholmod_l_read_matrix(stdin, 1, &mtype, cc);
    //~~~~~~~~~~~~~~~~~~~Starting computation~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    printf("================= ParU, a simple demo, using C interface : ====\n");
    ParU_C_Control Control;
    ParU_C_Init_Control(&Control);
    ParU_C_Analyze(A, &Sym, &Control);
    printf("Input matrix is %" PRId64 "x%" PRId64 " nnz = %" PRId64 " \n",
        Sym->m, Sym->n, Sym->anz);
    ParU_C_Numeric *Num;
    ParU_C_Factorize(A, Sym, &Num, &Control);

    //~~~~~~~~~~~~~~~~~~~ Computing the residual, norm(b-Ax) ~~~~~~~~~~~~~~~~~~~
    int64_t m = Sym->m;
    double *b = (double *)malloc(m * sizeof(double));
    double *xx = (double *)malloc(m * sizeof(double));
    for (int64_t i = 0; i < m; ++i) b[i] = i + 1;
    ParU_C_Solve_Axb(Sym, Num, b, xx, &Control);
    double resid, anorm, xnorm;
    ParU_C_Residual_bAx(A, xx, b, &resid, &anorm, &xnorm, &Control);
    double rresid = (anorm == 0 || xnorm == 0 ) ? 0 : (resid/(anorm*xnorm));
    printf( "Relative residual is |%.2e|, anorm is %.2e, xnorm is %.2e, "
        " and rcond is %.2e.\n",
        rresid, anorm, xnorm, Num->rcond);
    free(b);
    free(xx);

    //~~~~~~~~~~~~~~~~~~~End computation~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ParU_C_FreeNumeric(&Num, &Control);
    ParU_C_FreeSymbolic(&Sym, &Control);
    cholmod_l_free_sparse(&A, cc);
    cholmod_l_finish(cc);
}
\end{minted}

\subsection{{\sf ParU\_Info}: return values of each ParU method}

    All ParU C and C++ routines return an enum of type \verb'ParU_Info'.  The
    user application should check this return value before continuing.

    {\footnotesize
    \begin{verbatim}
    typedef enum ParU_Info
    {
        PARU_SUCCESS = 0,           // everying is fine
        PARU_OUT_OF_MEMORY = -1,    // ParU ran out of memory
        PARU_INVALID = -2,          // inputs are invalid (NULL, for example)
        PARU_SINGULAR = -3,         // matrix is numerically singular
        PARU_TOO_LARGE = -4         // problem too large for the BLAS
    } ParU_Info ; \end{verbatim}}

%-------------------------------------------------------------------------------
\section{C++ Syntax}
%-------------------------------------------------------------------------------

\subsection{{\sf ParU\_Version}: version of the ParU package}

    ParU has two mechanisms for informing the user application of its date and
    version: macros that are \verb'#define'd in \verb'ParU.h', and a
    \verb'ParU_Version' function.  Both methods are provided since it's
    possible that the \verb'ParU.h' header found when a user application was
    compiled might not match the same version found when the same user
    application was linked with the compiled ParU library.

    {\footnotesize
    \begin{verbatim}
    #define PARU_DATE "Apr XX, 2024"    // FIXME NOW
    #define PARU_VERSION_MAJOR  1
    #define PARU_VERSION_MINOR  0
    #define PARU_VERSION_UPDATE 0
    ParU_Info ParU_Version (int ver [3], char date [128]) ; \end{verbatim}}

    \verb'ParU_Version' returns the version in \verb'ver' array (major, minor,
    and update, in that order), and the date in the \verb'date' array provided
    by the user application.

\subsection{{\sf ParU\_Control}: parameters that control ParU}

    The \verb'ParU_Control' structure contains parameters that control various
    ParU options.  When declared, the structure is initialized with default
    values.  The user can then change the values.

    \vspace{0.1in}
    {\footnotesize
    \begin{tabular}{|lp{4in}|}
    \hline
    \verb'ParU_Control' & default value and explanation  \\
    \hline\hline
    \verb'mem_chunk' & default: $2^{20}$. Chunk size for parallel memset and memcpy. \\
    \verb'paru_max_threads' & default: $0$.  Maximum number of OpenMP threads to use.
        If zero (the default value), this is initialized with \verb'omp_max_threads'. \\
    \hline
    \verb'umfpack_ordering' & default: \verb'UMFPACK_ORDERING_AMD'. Default UMFPACK ordering. \\
    \verb'umfpack_strategy' & default: \verb'UMFPACK_STRATEGY_AUTO'. Default UMFPACK strategy. \\
    \verb'filter_singletons' & default: 1. If nonzero, singletons are
        permuted to the front of the matrix before factorization.  Singletons
        are rows or columns with a single entry (or have a single entry after
        other singletons are removed). \\
    \verb'relaxed_amalgamation' & default: 32. Threshold for relaxed amalgamation. When
        constructing its frontal matrices, ParU attempts to ensure that all
        frontal matrices contain at least this many pivot columns.  Values less
        than zero are treated as 32, and values greater than 512 are treated
        as 512. \\
    \hline
    \verb'prescale' & default: 1. 0: no scaling,
        1: each row is scaled by the maximum
        absolute value in the row. \\
    \verb'panel_width' & default: 32. Width of panel for dense factorization of each frontal matrix. \\
    \verb'paru_strategy' & default: \verb'PARU_STRATEGY_AUTO'. Default strategy for ParU. \\
    \verb'piv_toler' & default: $0.1$. Tolerance for accepting sparse pivots. \\
    \verb'diag_toler' & default: $0.001$. Tolerance for accepting symmetric pivots. \\
    \verb'trivial' & default: $4$. Do not call BLAS for smaller dgemms. \\
    \verb'worthwhile_dgemm' & default: $512$. dgemms bigger than this are tasked. \\
    \verb'worthwhile_trsm' & default: $4096$. trsm bigger than this are tasked. \\
    \hline
    \end{tabular}
    }
    \vspace{0.1in}

    The first section of the options in the table above is used in both the
    symbolic analysis and numerical factorization.  The second section of the
    options is used in the symbolic analysis.  The third section of control options
    shows those that have an impact on numerical factorization.

    If \verb'paru_strategy' is set to \verb'PARU_STRATEGY_AUTO'.  ParU uses the
    same strategy as UMFPACK. However, the user can ask UMFPACK for an
    unsymmetric strategy but use a symmetric strategy for ParU. Usually,
    UMFPACK chooses a good ordering; however, there might be cases where users
    prefer unsymmetric ordering on UMFPACK but symmetric computation on ParU.

    The \verb'ParU_Control' structure is defined below:

    {\footnotesize
    \begin{verbatim}
    struct ParU_Control
    {
        // For all phases of ParU:
        int64_t mem_chunk = PARU_MEM_CHUNK ;  // chunk size for memset and memcpy

        // Numeric factorization parameters:
        double piv_toler = 0.1 ;    // tolerance for accepting sparse pivots
        double diag_toler = 0.001 ; // tolerance for accepting symmetric pivots
        int32_t panel_width = 32 ;  // width of panel for dense factorizaiton
        int32_t trivial = 4 ;       // dgemms smaller than this do not call BLAS
        int32_t worthwhile_dgemm = 512 ; // dgemms bigger than this are tasked
        int32_t worthwhile_trsm = 4096 ; // trsm bigger than this are tasked
        int32_t prescale = 1 ;  // 0: no scaling, 1: scale each row by the max
            // absolute value in its row.

        // Symbolic analysis parameters:
        int32_t umfpack_ordering = UMFPACK_ORDERING_METIS ;
        int32_t umfpack_strategy = UMFPACK_STRATEGY_AUTO ;
        int32_t relaxed_amalgamation = 32 ;  // symbolic analysis tries to ensure
            // that each front have more pivot columns than this threshold
        int32_t paru_strategy = PARU_STRATEGY_AUTO ;
        int32_t filter_singletons = 1 ; // filter singletons if nonzero

        // For all phases of ParU:
        int32_t paru_max_threads = 0 ;  // initialized with omp_max_threads
    } ; \end{verbatim}}

\subsection{{\sf ParU\_Analyze}: symbolic analysis}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_Analyze
    (
        // input:
        cholmod_sparse *A,  // input matrix to analyze of size n-by-n
        // output:
        ParU_Symbolic **Sym_handle,  // output, symbolic analysis
        // control:
        ParU_Control *Control
    ) ; \end{verbatim}}

    \verb'ParU_Analyze' takes as input a sparse matrix in the CHOLMOD data
    structure, \verb'A'.  The matrix must be square and not held in the CHOLMOD
    symmetric storage format.  Refer to the CHOLMOD documentation for details.
    On output, the symbolic analysis structure \verb'Sym' is created, passed in as
    \verb'&Sym'.  The symbolic analysis can be used for different calls to
    \verb'ParU_Factorize' for matrices that have the same sparsity pattern but
    different numerical values.  Details of the \verb'ParU_Symbolic' structure
    are available in the \verb'ParU.h' file.
    The symbolic analysis structure must be freed by \verb'ParU_FreeSymbolic'.

\subsection{{\sf ParU\_Factorize}: numerical factorization}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_Factorize
    (
        // input:
        cholmod_sparse *A,  // input matrix to factorize
        ParU_Symbolic *Sym, // symbolic analsys from ParU_Analyze
        // output:
        ParU_Numeric **Num_handle,
        // control:
        ParU_Control *Control
    ) ; \end{verbatim}}

    \verb'ParU_Factorize' performs the numerical factorization of its input
    sparse matrix \verb'A'.  The symbolic analsys \verb'Sym' must have been
    created by a prior call to \verb'ParU_Analyze' with the same matrix
    \verb'A', or one with the same sparsity pattern as the one passed to
    \verb'ParU_Factorize'.  On output, the \verb'&Num' structure is created.
    Details of the \verb'ParU_Numeric' structure are available in the \verb'ParU.h' file.
    The numeric factorization structure must be freed by \verb'ParU_FreeNumeric'.

\subsection{{\sf ParU\_Solve}: solve a linear system, $Ax=b$}

    \verb'ParU_Solve' solves a sparse linear system $Ax=b$ for a sparse
    matrix \verb'A' and vectors \verb'x' and \verb'b', or matrices
    \verb'X' and \verb'B'.  The matrix \verb'A' must have been factorized
    by \verb'ParU_Factorize', and the \verb'Sym' and \verb'Num' structures
    from that call must be passed to this method.

    The method has four overloaded signatures, so that it can handle a single
    right-hand-side vector or a matrix with multiple right-hand-sides, and it
    provides the option of overwriting the input right-hand-side(s) with the
    solution(s).

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_Solve        // solve Ax=b, overwriting b with the solution x
    (
        // input:
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        // input/output:
        double *x,              // vector of size n-by-1; right-hand on input,
                                // solution on output
        // control:
        ParU_Control *Control
    ) ;

    ParU_Info ParU_Solve        // solve Ax=b
    (
        // input:
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        double *b,              // vector of size n-by-1
        // output
        double *x,              // vector of size n-by-1
        // control:
        ParU_Control *Control
    ) ;

    ParU_Info ParU_Solve        // solve AX=B, overwriting B with the solution X
    (
        // input
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        int64_t nrhs,           // # of right-hand sides
        // input/output:
        double *X,              // X is n-by-nrhs, where A is n-by-n;
                                // holds B on input, solution X on input
        // control:
        ParU_Control *Control
    ) ;

    ParU_Info ParU_Solve        // solve AX=B
    (
        // input
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        int64_t nrhs,           // # of right-hand sides
        double *B,              // n-by-nrhs, in column-major storage
        // output:
        double *X,              // n-by-nrhs, in column-major storage
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_LSolve}: solve a linear system, $Lx=b$}

    \verb'ParU_LSolve' solves a lower triangular system, $Lx=b$ with vectors
    $x$ and $b$, or $LX=B$ with matrices $X$ and $B$, using the lower
    triangular factor computed by \verb'ParU_Factorize'.  No scaling or
    permutations are used.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_LSolve
    (
        // input
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        // input/output:
        double *x,              // n-by-1, in column-major storage;
                                // holds b on input, solution x on input
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_LSolve
    (
        // input
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        int64_t nrhs,           // # of right-hand-sides (# columns of X)
        // input/output:
        double *X,              // X is n-by-nrhs, where A is n-by-n;
                                // holds B on input, solution X on input
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_USolve}: solve a linear system, $Ux=b$}

    \verb'ParU_USolve' solves an upper triangular system, $Ux=b$ with vectors
    $x$ and $b$, or $UX=B$ with matrices $X$ and $B$, using the upper
    triangular factor computed by \verb'ParU_Factorize'.  No scaling or
    permutations are used.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_USolve
    (
        // input
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        // input/output
        double *x,              // n-by-1, in column-major storage;
                                // holds b on input, solution x on input
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_USolve
    (
        // input
        ParU_Symbolic *Sym,     // symbolic analysis from ParU_Analyze
        ParU_Numeric *Num,      // numeric factorization from ParU_Factorize
        int64_t nrhs,           // # of right-hand-sides (# columns of X)
        // input/output:
        double *X,              // X is n-by-nrhs, where A is n-by-n;
                                // holds B on input, solution X on input
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_Perm}: permute and scale a dense vector or matrix}
\label{perm}

    \verb'ParU_Perm' permutes and optionally scales a vector $b$ or matrix $B$.
    If the input \verb's' is \verb'NULL', no scaling is applied.  The
    permutation vector \verb'P' has size \verb'n'.  If the $k$th index in the
    permutation is row $i$, then \verb'i = P[k]'.

    For the vector case, the output is $x(k) = b(P(k)) / s(P(k))$, or
    $x(k) = b(P(k))$, or if \verb's' is \verb'NULL', for all $k$ in the range 0
    to $n-1$.

    For the matrix case, the output is $X(k,j) = B(P(k),j) / s(P(k))$ for all
    rows $k$ and all columns $j$ of $X$ and $B$.  If \verb's' is \verb'NULL',
    then the output is $X(k,j) = B(P(k),j)$.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_Perm
    (
        // inputs
        const int64_t *P,   // permutation vector of size n
        const double *s,    // vector of size n (optional)
        const double *b,    // vector of size n
        int64_t n,          // length of P, s, B, and X
        // output
        double *x,          // vector of size n
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_Perm
    (
        // inputs
        const int64_t *P,   // permutation vector of size nrows
        const double *s,    // vector of size nrows (optional)
        const double *B,    // array of size nrows-by-ncols
        int64_t nrows,      // # of rows of X and B
        int64_t ncols,      // # of columns of X and B
        // output
        double *X,          // array of size nrows-by-ncols
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_InvPerm}: permute and scale a dense vector or matrix}
\label{invperm}

    \verb'ParU_InvPerm' permutes and optionally scales a vector $b$ or matrix $B$.
    If the input \verb's' is \verb'NULL', no scaling is applied.  The
    permutation vector \verb'P' has size \verb'n', and its inverse is
    implicitly used by this method.  If the $k$th index in the permutation is
    row $i$, then \verb'i = P[k]'.

    For the vector case, the output is $x(P(k)) = b(k) / s(P(k))$, or
    $x(P(k)) = b(k)$, or if \verb's' is \verb'NULL', for all $k$ in the range 0
    to $n-1$.

    For the matrix case, the output is $X(P(k),j) = B(k,j) / s(P(k))$ for all
    rows $k$ and all columns $j$ of $X$ and $B$.  If \verb's' is \verb'NULL',
    then the output is $X(P(k),j) = B(k,j)$.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_InvPerm
    (
        // inputs
        const int64_t *P,   // permutation vector of size n
        const double *s,    // vector of size n (optional)
        const double *b,    // vector of size n
        int64_t n,          // length of P, s, B, and X
        // output
        double *x,          // vector of size n
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_InvPerm
    (
        // inputs
        const int64_t *P,   // permutation vector of size nrows
        const double *s,    // vector of size nrows (optional)
        const double *B,    // array of size nrows-by-ncols
        int64_t nrows,      // # of rows of X and B
        int64_t ncols,      // # of columns of X and B
        // output
        double *X,          // array of size nrows-by-ncols
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

    The \verb'ParU_LSolve', \verb'ParU_USolve', \verb'ParU_Perm', and
    \verb'ParU_InvPerm' can be used together to solve $Ax=b$ or $AX=B$.  For
    example, if \verb't' is a temporary vector of size \verb'n', and $A$ is an
    $n$-by-$n$ matrix, calling \verb'ParU_Solve' to solve $Ax=b$ is identical
    to the following (ignoring any tests for error conditions):

    {\footnotesize
    \begin{verbatim}
    ParU_Perm (Num->Pfin, Num->Rs, b, n, t, Control) ;
    ParU_LSolve (Sym, Num, t, Control) ;
    ParU_USolve (Sym, Num, t, Control) ;
    ParU_InvPerm (Sym->Qfill, NULL, t, n, x, Control) ; \end{verbatim} }

    The numeric factorization \verb'Num' contains the row permutation vector
    \verb'Num->Pfin' from partial pivoting, and the row scaling vector
    \verb'Num->Rs'.  The symbolic analysis structure \verb'Sym' contains the
    fill-reducing column preordering, \verb'Sym->Qfill'.

\subsection{{\sf ParU\_Residual}: compute the residual}

    The \verb'ParU_Residual' function computes the relative residual of
    $Ax=b$ or $AX=B$, in the 1-norm.  It also computes the 1-norm of $A$
    and the solution $X$ or $x$.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_Residual
    (
        // inputs:
        cholmod_sparse *A,  // an n-by-n sparse matrix
        double *x,          // vector of size n
        double *b,          // vector of size n
        // output:
        double &resid,      // residual: norm1(b-A*x) / (norm1(A) * norm1 (x))
        double &anorm,      // 1-norm of A
        double &xnorm,      // 1-norm of x
        // control:
        ParU_Control *Control
    ) ;

    ParU_Info ParU_Residual
    (
        // inputs:
        cholmod_sparse *A,  // an n-by-n sparse matrix
        double *X,          // array of size n-by-nrhs
        double *B,          // array of size n-by-nrhs
        int64_t nrhs,
        // output:
        double &resid,      // residual: norm1(B-A*X) / (norm1(A) * norm1 (X))
        double &anorm,      // 1-norm of A
        double &xnorm,      // 1-norm of X
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_FreeNumeric}: free a numeric factorization}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_FreeNumeric
    (
        // input/output:
        ParU_Numeric **Num_handle,  // numeric object to free
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_FreeSymbolic}: free a symbolic analysis}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_FreeSymbolic
    (
        // input/output:
        ParU_Symbolic **Sym_handle, // symbolic object to free
        // control:
        ParU_Control *Control
    ) ; \end{verbatim} }

%-------------------------------------------------------------------------------
\section{C Syntax}
%-------------------------------------------------------------------------------

The C interface is quite similar to the C++ interface.  The next sections
describe the user-callable C functions, their prototypes, and what they can do.

\subsection{{\sf ParU\_C\_Version}: version of the ParU package}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Version (int ver [3], char date [128]) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Init\_Control}: sets the control parameters to defaults}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Init_Control (ParU_C_Control *Control_C) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Analyze}: symbolic analysis}

    \verb'ParU_C_Analyze' performs the symbolic analysis of a sparse
        matrix, based solely on its nonzero pattern.  \verb'ParU_C_Analyze' is
        called once and can be used for different \verb'ParU_C_Factorize' calls
        for the matrices that have the same pattern but different numerical
        values.
        The symbolic analysis structure must be freed by \verb'ParU_C_FreeSymbolic'.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Analyze
    (
        // input:
        cholmod_sparse *A,  // input matrix to analyze of size n-by-n
        // output:
        ParU_C_Symbolic **Sym_handle_C,  // output, symbolic analysis
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Factorize}: numeric factorization}

    \verb'ParU_C_Factorize' computes the numeric factorization.  The
    \verb'ParU_C_Symbolic' structure computed in \verb'ParU_C_Analyze' is an
    input to this routine.
    The numeric factorization structure must be freed by \verb'ParU_C_FreeNumeric'.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Factorize
    (
        // input:
        cholmod_sparse *A,          // input matrix to factorize of size n-by-n
        ParU_C_Symbolic *Sym_C,     // symbolic analysis from ParU_Analyze
        // output:
        ParU_C_Numeric **Num_handle_C,    // output numerical factorization
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Solve\_A*}: solve a linear system, $Ax=b$}

    The \verb'ParU_C_Solve_Axx',  \verb'ParU_C_Solve_Axb',
        \verb'ParU_C_Solve_AXX' and \verb'ParU_C_Solve_AXB'
        methods solve a sparse linear system $Ax=b$ for a sparse
        matrix \verb'A' and vectors \verb'x' and \verb'b', or matrices
        \verb'X' and \verb'B'.  The matrix \verb'A' must have been factorized
        by \verb'ParU_Factorize', and the \verb'Sym' and \verb'Num' structures
        from that call must be passed to this method.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_Axx
    (
        // input:
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        // input/output:
        double *x,              // vector of size n-by-1; right-hand on input,
                                // solution on output
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_Axb
    (
        // input:
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        double *b,              // vector of size n-by-1
        // output
        double *x,              // vector of size n-by-1
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_AXX
    (
        // input
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        int64_t nrhs,
        // input/output:
        double *X,              // array of size n-by-nrhs in column-major storage,
                                // right-hand-side on input, solution on output.
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_AXB
    (
        // input
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        int64_t nrhs,
        double *B,              // array of size n-by-nrhs in column-major storage
        // output:
        double *X,              // array of size n-by-nrhs in column-major storage
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Solve\_L*}: solve a linear system, $Lx=b$}

    The \verb'ParU_C_Solve_Lxx' and \verb'ParU_C_Solve_LXX' methods solve lower
    triangular systems, $Lx=b$ with vectors $x$ and $b$, or $LX=B$ with
    matrices $X$ and $B$, using the lower triangular factor computed by
    \verb'ParU_Factorize'.  No scaling or permutations are used.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_Lxx
    (
        // input:
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        // input/output:
        double *x,              // vector of size n-by-1; right-hand on input,
                                // solution on output
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_LXX
    (
        // input
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        int64_t nrhs,
        // input/output:
        double *X,              // array of size n-by-nrhs in column-major storage,
                                // right-hand-side on input, solution on output.
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Solve\_U*}: solve a linear system, $Ux=b$}

    The \verb'ParU_C_Solve_Uxx' and \verb'ParU_C_Solve_UXX' methods solve an
    upper triangular system, $Ux=b$ or $UX=B$.  No scaling or permutation is
    performed.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_Uxx
    (
        // input:
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        // input/output:
        double *x,              // vector of size n-by-1; right-hand on input,
                                // solution on output
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Solve_UXX
    (
        // input
        ParU_C_Symbolic *Sym_C, // symbolic analysis from ParU_C_Analyze
        ParU_C_Numeric *Num_C,  // numeric factorization from ParU_C_Factorize
        int64_t nrhs,
        // input/output:
        double *X,              // array of size n-by-nrhs in column-major storage,
                                // right-hand-side on input, solution on output.
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Perm}: permute and scale a dense vector or matrix}

    \verb'ParU_C_Perm' and \verb'ParU_C_Perm_X' permutes and optionally scale a
    dense vector or matrix.  Refer to Section \ref{perm} for details.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Perm
    (
        // inputs
        const int64_t *P,   // permutation vector of size n
        const double *s,    // vector of size n (optional)
        const double *b,    // vector of size n
        int64_t n,          // length of P, s, B, and X
        // output
        double *x,          // vector of size n
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Perm_X
    (
        // inputs
        const int64_t *P,   // permutation vector of size nrows
        const double *s,    // vector of size nrows (optional)
        const double *B,    // array of size nrows-by-ncols
        int64_t nrows,      // # of rows of X and B
        int64_t ncols,      // # of columns of X and B
        // output
        double *X,          // array of size nrows-by-ncols
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_InvPerm}: permute and scale a dense vector or matrix}

    \verb'ParU_C_InvPerm' and \verb'ParU_C_InvPerm_X' and permutes and
    optionally scale a dense vector or matrix.  Refer to Section \ref{invperm} for
    details.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_InvPerm
    (
        // inputs
        const int64_t *P,   // permutation vector of size n
        const double *s,    // vector of size n (optional)
        const double *b,    // vector of size n
        int64_t n,          // length of P, s, B, and X
        // output
        double *x,          // vector of size n
        // control
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_InvPerm_X
    (
        // inputs
        const int64_t *P,   // permutation vector of size nrows
        const double *s,    // vector of size nrows (optional)
        const double *B,    // array of size nrows-by-ncols
        int64_t nrows,      // # of rows of X and B
        int64_t ncols,      // # of columns of X and B
        // output
        double *X,          // array of size nrows-by-ncols
        // control
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_Residual\_*}: compute the residual}

    \verb'ParU_C_Residual_bAx' and \verb'ParU_C_Residual_BAX' compute the
    relative residual of $Ax=b$ or $AX=B$, in the 1-norm, and the 1-norm of $A$
    and the solution $X$ or $x$.

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Residual_bAx
    (
        // inputs:
        cholmod_sparse *A,  // an n-by-n sparse matrix
        double *x,          // vector of size n
        double *b,          // vector of size n
        // output:
        double *residc,     // residual: norm1(b-A*x) / (norm1(A) * norm1 (x))
        double *anormc,     // 1-norm of A
        double *xnormc,     // 1-norm of x
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_Residual_BAX
    (
        // inputs:
        cholmod_sparse *A,  // an n-by-n sparse matrix
        double *X,          // array of size n-by-nrhs
        double *B,          // array of size n-by-nrhs
        int64_t nrhs,
        // output:
        double *residc,     // residual: norm1(B-A*X) / (norm1(A) * norm1 (X))
        double *anormc,     // 1-norm of A
        double *xnormc,     // 1-norm of X
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_FreeNumeric}: free the numeric factorization}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_FreeNumeric
    (
        ParU_C_Numeric **Num_handle_C,    // numeric object to free
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

\subsection{{\sf ParU\_C\_FreeSymbolic}: free the symbolic analysis structure}

    {\footnotesize
    \begin{verbatim}
    ParU_Info ParU_C_FreeSymbolic
    (
        ParU_C_Symbolic **Sym_handle_C,   // symbolic object to free
        // control:
        ParU_C_Control *Control_C
    ) ; \end{verbatim} }

%-------------------------------------------------------------------------------
\section{Using ParU in MATLAB}
%-------------------------------------------------------------------------------

% FIXME: describe paru mexFunction

%-------------------------------------------------------------------------------
\section{Requirements and Availability}
\label{summary}
%-------------------------------------------------------------------------------

ParU requires several Collected Algorithms of the ACM: CHOLMOD
\cite{ChenDavisHagerRajamanickam09,DavisHager09}, AMD
\cite{AmestoyDavisDuff96,AmestoyDavisDuff03}, COLAMD
\cite{DavisGilbertLarimoreNg00_algo,DavisGilbertLarimoreNg00} and UMFPACK
\cite{10.1145/992200.992206} for its ordering/analysis phase and for its basic
sparse matrix data structure, and the BLAS \cite{dddh:90} for dense matrix
computations on its frontal matrices.  An efficient implementation of the BLAS
is strongly recommended, either vendor-provided (such as the Intel MKL, the AMD
ACML, or the Sun Performance Library) or other high-performance BLAS such as
those of \cite{GotoVanDeGeijn08}. Note that while ParU uses nested parallelism
heavily the right options for the BLAS library must be chosen to get a good
performance.

SuiteSparse uses a slightly modified version of METIS 5.1.0, distributed along
with SuiteSparse itself.  Its use is optional, however. ParU uses AMD as its
default ordering. METIS tends to give orderings that are good for parallelism.
However, METIS itself can be slower than AMD. As a result, the symbolic
analysis using METIS can be slow, but usually, the factorization is faster.
Therefore, depending on your use case, either use METIS, or you can compile and
run your code without using METIS.  If you are using METIS on an unsymmetric
case, UMFPACK must form the Matrix $A^{T}A$. This matrix can have many entries
it takes a lot of resources to form it. To avoid such conditions, you can use
the ordering strategy \verb'UMFPACK_ORDERING_METIS_GUARD' that is introduced in
UMFPACK version 6.0.  This ordering strategy use COLAMD instead of METIS in
when $A^T A$ is too costly to perform.

The use of OpenMP tasking is optional, but without it, only parallelism within
the BLAS can be exploited (if available).

See \verb'ParU/LICENSE.txt' for the license.  Alternative licenses are also
available; contact the authors for details.

%-------------------------------------------------------------------------------
% References
%-------------------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{paru_user_guide}
\end{document}
